<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Part of Speech Tagging with Hidden Markov Models | A noobs’ blog</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Part of Speech Tagging with Hidden Markov Models" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An introductory blog on approaching Machine Learning/Deep Learning Problems." />
<meta property="og:description" content="An introductory blog on approaching Machine Learning/Deep Learning Problems." />
<link rel="canonical" href="https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html" />
<meta property="og:url" content="https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html" />
<meta property="og:site_name" content="A noobs’ blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-02T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"An introductory blog on approaching Machine Learning/Deep Learning Problems.","@type":"BlogPosting","headline":"Part of Speech Tagging with Hidden Markov Models","dateModified":"2020-06-02T00:00:00-05:00","datePublished":"2020-06-02T00:00:00-05:00","url":"https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/DumbMachine/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://ehtasham.github.io/DumbMachine/feed.xml" title="A noobs' blog" /><link rel="shortcut icon" type="image/x-icon" href="/DumbMachine/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Part of Speech Tagging with Hidden Markov Models | A noobs’ blog</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Part of Speech Tagging with Hidden Markov Models" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An introductory blog on approaching Machine Learning/Deep Learning Problems." />
<meta property="og:description" content="An introductory blog on approaching Machine Learning/Deep Learning Problems." />
<link rel="canonical" href="https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html" />
<meta property="og:url" content="https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html" />
<meta property="og:site_name" content="A noobs’ blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-02T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"An introductory blog on approaching Machine Learning/Deep Learning Problems.","@type":"BlogPosting","headline":"Part of Speech Tagging with Hidden Markov Models","dateModified":"2020-06-02T00:00:00-05:00","datePublished":"2020-06-02T00:00:00-05:00","url":"https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://ehtasham.github.io/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://ehtasham.github.io/DumbMachine/feed.xml" title="A noobs' blog" />

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/DumbMachine/">A noobs&#39; blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/DumbMachine/about/">About Me</a><a class="page-link" href="/DumbMachine/search/">Search</a><a class="page-link" href="/DumbMachine/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Part of Speech Tagging with Hidden Markov Models</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-06-02T00:00:00-05:00" itemprop="datePublished">
        Jun 2, 2020
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      21 min read
    
</span></p>

    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          <div class="px-2">

    <a href="https://github.com/ehtasham/DumbMachine/tree/master/_notebooks/2020-06-02-Part-of-Speech-Tagging-with-Hidden-Markov-Models.ipynb" role="button" target="_blank">
<img class="notebook-badge-image" src="/DumbMachine/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

          <div class="px-2">
    <a href="https://mybinder.org/v2/gh/ehtasham/DumbMachine/master?filepath=_notebooks%2F2020-06-02-Part-of-Speech-Tagging-with-Hidden-Markov-Models.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/DumbMachine/assets/badges/binder.svg" alt="Open In Binder"/>
    </a>
</div>

          <div class="px-2">
    <a href="https://colab.research.google.com/github/ehtasham/DumbMachine/blob/master/_notebooks/2020-06-02-Part-of-Speech-Tagging-with-Hidden-Markov-Models.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/DumbMachine/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-06-02-Part-of-Speech-Tagging-with-Hidden-Markov-Models.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Introduction">Introduction<a class="anchor-link" href="#Introduction"> </a></h3><p>Part of speech tagging is the process of determining the syntactic category of a word from the words in its surrounding context. It is often used to help disambiguate natural language phrases because it can be done quickly with high accuracy. Tagging can be used for many NLP tasks like determining correct pronunciation during speech synthesis (for example, <em>dis</em>-count as a noun vs dis-<em>count</em> as a verb), for information retrieval, and for word sense disambiguation.</p>
<p>In this notebook, we'll use the <a href="http://pomegranate.readthedocs.io/">Pomegranate</a> library to build a hidden Markov model for part of speech tagging using a "universal" tagset. Hidden Markov models have been able to achieve <a href="http://www.coli.uni-saarland.de/~thorsten/publications/Brants-ANLP00.pdf">&gt;96% tag accuracy with larger tagsets on realistic text corpora</a>. Hidden Markov models have also been used for speech recognition and speech generation, machine translation, gene recognition for bioinformatics, and human gesture recognition for computer vision, and more.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-Road-Ahead">The Road Ahead<a class="anchor-link" href="#The-Road-Ahead"> </a></h3><ul>
<li><a href="#Step-1:-Read-and-preprocess-the-dataset">Step 1</a>: Review the provided interface to load and access the text corpus</li>
<li><a href="#Step-2:-Build-a-Most-Frequent-Class-tagger">Step 2</a>: Build a Most Frequent Class tagger to use as a baseline</li>
<li><a href="#Step-3:-Build-an-HMM-tagger">Step 3</a>: Build an HMM Part of Speech tagger and compare to the MFC baseline</li>
<li><a href="#Step-4:-[Optional]-Improving-model-performance">Step 4</a>: (Optional) Improve the HMM tagger</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Jupyter &quot;magic methods&quot; -- only need to be run once per kernel restart</span>
<span class="o">%</span><span class="k">load_ext</span> autoreload
<span class="o">%</span><span class="k">aimport</span> helpers, tests
<span class="o">%</span><span class="k">autoreload</span> 1
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># import python modules -- this cell needs to be run again if you make changes to any of the files</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">IPython.core.display</span> <span class="kn">import</span> <span class="n">HTML</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">helpers</span> <span class="kn">import</span> <span class="n">show_model</span><span class="p">,</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">pomegranate</span> <span class="kn">import</span> <span class="n">State</span><span class="p">,</span> <span class="n">HiddenMarkovModel</span><span class="p">,</span> <span class="n">DiscreteDistribution</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Step-1:-Read-and-preprocess-the-dataset">Step 1: Read and preprocess the dataset<a class="anchor-link" href="#Step-1:-Read-and-preprocess-the-dataset"> </a></h2><hr />
<p>We'll start by reading in a text corpus and splitting it into a training and testing dataset. The data set is a copy of the <a href="https://en.wikipedia.org/wiki/Brown_Corpus">Brown corpus</a> (originally from the <a href="https://www.nltk.org/">NLTK</a> library) that has already been pre-processed to only include the <a href="https://arxiv.org/pdf/1104.2086.pdf">universal tagset</a>.</p>
<p>The <code>Dataset</code> class provided in helpers.py will read and parse the corpus. The dataset is stored in plaintext as a collection of words and corresponding tags. Each sentence starts with a unique identifier on the first line, followed by one tab-separated word/tag pair on each following line. Sentences are separated by a single blank line.</p>
<p>Example from the Brown corpus.</p>

<pre><code>b100-38532
Perhaps ADV
it  PRON
was VERB
right   ADJ
;   .
;   .

b100-35577
...</code></pre>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="s2">&quot;tags-universal.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;brown-universal.txt&quot;</span><span class="p">,</span> <span class="n">train_test_split</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> sentences in the corpus.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> sentences in the training set.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> sentences in the testing set.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="p">)))</span>

<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="p">),</span> \
       <span class="s2">&quot;The number of sentences in the training set + testing set should sum to the number of sentences in the corpus&quot;</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>There are 57340 sentences in the corpus.
There are 45872 sentences in the training set.
There are 11468 sentences in the testing set.
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-Dataset-Interface">The Dataset Interface<a class="anchor-link" href="#The-Dataset-Interface"> </a></h3><p>You can access (mostly) immutable references to the dataset through a simple interface provided through the <code>Dataset</code> class, which represents an iterable collection of sentences along with easy access to partitions of the data for training &amp; testing. Review the reference below, then run and review the next few cells to make sure you understand the interface before moving on to the next step.</p>

<pre><code>Dataset-only Attributes:
    training_set - reference to a Subset object containing the samples for training
    testing_set - reference to a Subset object containing the samples for testing

Dataset &amp; Subset Attributes:
    sentences - a dictionary with an entry {sentence_key: Sentence()} for each sentence in the corpus
    keys - an immutable ordered (not sorted) collection of the sentence_keys for the corpus
    vocab - an immutable collection of the unique words in the corpus
    tagset - an immutable collection of the unique tags in the corpus
    X - returns an array of words grouped by sentences ((w11, w12, w13, ...), (w21, w22, w23, ...), ...)
    Y - returns an array of tags grouped by sentences ((t11, t12, t13, ...), (t21, t22, t23, ...), ...)
    N - returns the number of distinct samples (individual words or tags) in the dataset

Methods:
    stream() - returns an flat iterable over all (word, tag) pairs across all sentences in the corpus
    __iter__() - returns an iterable over the data as (sentence_key, Sentence()) pairs
    __len__() - returns the nubmer of sentences in the dataset</code></pre>
<p>For example, consider a Subset, <code>subset</code>, of the sentences <code>{"s0": Sentence(("See", "Spot", "run"), ("VERB", "NOUN", "VERB")), "s1": Sentence(("Spot", "ran"), ("NOUN", "VERB"))}</code>. The subset will have these attributes:</p>

<pre><code>subset.keys == {"s1", "s0"}  # unordered
subset.vocab == {"See", "run", "ran", "Spot"}  # unordered
subset.tagset == {"VERB", "NOUN"}  # unordered
subset.X == (("Spot", "ran"), ("See", "Spot", "run"))  # order matches .keys
subset.Y == (("NOUN", "VERB"), ("VERB", "NOUN", "VERB"))  # order matches .keys
subset.N == 7  # there are a total of seven observations over all sentences
len(subset) == 2  # because there are two sentences</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Sentences">Sentences<a class="anchor-link" href="#Sentences"> </a></h4><p><code>Dataset.sentences</code> is a dictionary of all sentences in the training corpus, each keyed to a unique sentence identifier. Each <code>Sentence</code> is itself an object with two attributes: a tuple of the words in the sentence named <code>words</code> and a tuple of the tag corresponding to each word named <code>tags</code>.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;b100-38532&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sentence: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;words:</span><span class="se">\n\t</span><span class="si">{!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sentences</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">words</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tags:</span><span class="se">\n\t</span><span class="si">{!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sentences</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">tags</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Sentence: b100-38532
words:
	(&#39;Perhaps&#39;, &#39;it&#39;, &#39;was&#39;, &#39;right&#39;, &#39;;&#39;, &#39;;&#39;)
tags:
	(&#39;ADV&#39;, &#39;PRON&#39;, &#39;VERB&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;.&#39;)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Counting-Unique-Elements">Counting Unique Elements<a class="anchor-link" href="#Counting-Unique-Elements"> </a></h4><p>You can access the list of unique words (the dataset vocabulary) via <code>Dataset.vocab</code> and the unique list of tags via <code>Dataset.tagset</code>.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are a total of </span><span class="si">{}</span><span class="s2"> samples of </span><span class="si">{}</span><span class="s2"> unique words in the corpus.&quot;</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">vocab</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> samples of </span><span class="si">{}</span><span class="s2"> unique words in the training set.&quot;</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">vocab</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> samples of </span><span class="si">{}</span><span class="s2"> unique words in the testing set.&quot;</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">vocab</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{}</span><span class="s2"> words in the test set that are missing in the training set.&quot;</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">vocab</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">vocab</span><span class="p">)))</span>

<span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> \
       <span class="s2">&quot;The number of training + test samples should sum to the total number of samples&quot;</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>There are a total of 1161192 samples of 56057 unique words in the corpus.
There are 928458 samples of 50536 unique words in the training set.
There are 232734 samples of 25112 unique words in the testing set.
There are 5521 words in the test set that are missing in the training set.
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Accessing-word-and-tag-Sequences">Accessing word and tag Sequences<a class="anchor-link" href="#Accessing-word-and-tag-Sequences"> </a></h4><p>The <code>Dataset.X</code> and <code>Dataset.Y</code> attributes provide access to ordered collections of matching word and tag sequences for each sentence in the dataset.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># accessing words with Dataset.X and tags with Dataset.Y </span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sentence </span><span class="si">{}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Labels </span><span class="si">{}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Sentence 1: (&#39;Mr.&#39;, &#39;Podger&#39;, &#39;had&#39;, &#39;thanked&#39;, &#39;him&#39;, &#39;gravely&#39;, &#39;,&#39;, &#39;and&#39;, &#39;now&#39;, &#39;he&#39;, &#39;made&#39;, &#39;use&#39;, &#39;of&#39;, &#39;the&#39;, &#39;advice&#39;, &#39;.&#39;)

Labels 1: (&#39;NOUN&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;PRON&#39;, &#39;ADV&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADV&#39;, &#39;PRON&#39;, &#39;VERB&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;.&#39;)

Sentence 2: (&#39;But&#39;, &#39;there&#39;, &#39;seemed&#39;, &#39;to&#39;, &#39;be&#39;, &#39;some&#39;, &#39;difference&#39;, &#39;of&#39;, &#39;opinion&#39;, &#39;as&#39;, &#39;to&#39;, &#39;how&#39;, &#39;far&#39;, &#39;the&#39;, &#39;board&#39;, &#39;should&#39;, &#39;go&#39;, &#39;,&#39;, &#39;and&#39;, &#39;whose&#39;, &#39;advice&#39;, &#39;it&#39;, &#39;should&#39;, &#39;follow&#39;, &#39;.&#39;)

Labels 2: (&#39;CONJ&#39;, &#39;PRT&#39;, &#39;VERB&#39;, &#39;PRT&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADP&#39;, &#39;ADV&#39;, &#39;ADV&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;PRON&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;.&#39;)

</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Accessing-(word,-tag)-Samples">Accessing (word, tag) Samples<a class="anchor-link" href="#Accessing-(word,-tag)-Samples"> </a></h4><p>The <code>Dataset.stream()</code> method returns an iterator that chains together every pair of (word, tag) entries across all sentences in the entire corpus.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># use Dataset.stream() (word, tag) samples for the entire corpus</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Stream (word, tag) pairs:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">stream</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pair</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span> <span class="k">break</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
Stream (word, tag) pairs:

	 (&#39;Mr.&#39;, &#39;NOUN&#39;)
	 (&#39;Podger&#39;, &#39;NOUN&#39;)
	 (&#39;had&#39;, &#39;VERB&#39;)
	 (&#39;thanked&#39;, &#39;VERB&#39;)
	 (&#39;him&#39;, &#39;PRON&#39;)
	 (&#39;gravely&#39;, &#39;ADV&#39;)
	 (&#39;,&#39;, &#39;.&#39;)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For both our baseline tagger and the HMM model we'll build, we need to estimate the frequency of tags &amp; words from the frequency counts of observations in the training corpus. In the next several cells you will complete functions to compute the counts of several sets of counts.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Step-2:-Build-a-Most-Frequent-Class-tagger">Step 2: Build a Most Frequent Class tagger<a class="anchor-link" href="#Step-2:-Build-a-Most-Frequent-Class-tagger"> </a></h2><hr />
<p>Perhaps the simplest tagger (and a good baseline for tagger performance) is to simply choose the tag most frequently assigned to each word. This "most frequent class" tagger inspects each observed word in the sequence and assigns it the label that was most often assigned to that word in the corpus.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="IMPLEMENTATION:-Pair-Counts">IMPLEMENTATION: Pair Counts<a class="anchor-link" href="#IMPLEMENTATION:-Pair-Counts"> </a></h3><p>Complete the function below that computes the joint frequency counts for two input sequences.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">pair_counts</span><span class="p">(</span><span class="n">sequences_A</span><span class="p">,</span> <span class="n">sequences_B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a dictionary keyed to each unique value in the first sequence list</span>
<span class="sd">    that counts the number of occurrences of the corresponding value from the</span>
<span class="sd">    second sequences list.</span>
<span class="sd">    </span>
<span class="sd">    For example, if sequences_A is tags and sequences_B is the corresponding</span>
<span class="sd">    words, then if 1244 sequences contain the word &quot;time&quot; tagged as a NOUN, then</span>
<span class="sd">    you should return a dictionary such that pair_counts[NOUN][time] == 1244</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
    <span class="n">pair_count</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1">#iterate over both sequences and add them to dictionary</span>
    <span class="k">for</span> <span class="n">gram</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">sequences_A</span><span class="p">),</span> <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">sequences_B</span><span class="p">))):</span>
        <span class="c1">#if key is not in dictionary, initialize its frequency with 1</span>
        <span class="k">if</span> <span class="n">gram</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pair_count</span><span class="p">:</span>
            <span class="n">pair_count</span><span class="p">[</span><span class="n">gram</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">word</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#update the frequency if key is in dictionary and word is not in dictionary</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pair_count</span><span class="p">[</span><span class="n">gram</span><span class="p">]:</span>
                <span class="n">pair_count</span><span class="p">[</span><span class="n">gram</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">word</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
            <span class="c1">#update the frequency if key and word are in dictionary</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pair_count</span><span class="p">[</span><span class="n">gram</span><span class="p">][</span><span class="n">word</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">pair_count</span>
            
    

<span class="c1"># Calculate C(t_i, w_i)</span>
<span class="n">emission_counts</span><span class="o">=</span> <span class="n">pair_counts</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">emission_counts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span><span class="p">,</span> \
       <span class="s2">&quot;Uh oh. There should be 12 tags in your dictionary.&quot;</span>
<span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">emission_counts</span><span class="p">[</span><span class="s2">&quot;NOUN&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">emission_counts</span><span class="p">[</span><span class="s2">&quot;NOUN&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> \
       <span class="s2">&quot;Hmmm...&#39;time&#39; is expected to be the most common NOUN.&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your emission counts look good!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your emission counts look good!</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="IMPLEMENTATION:-Most-Frequent-Class-Tagger">IMPLEMENTATION: Most Frequent Class Tagger<a class="anchor-link" href="#IMPLEMENTATION:-Most-Frequent-Class-Tagger"> </a></h3><p>Use the <code>pair_counts()</code> function and the training dataset to find the most frequent class label for each word in the training data, and populate the <code>mfc_table</code> below. The table keys should be words, and the values should be the appropriate tag string.</p>
<p>The <code>MFCTagger</code> class is provided to mock the interface of Pomegranite HMM models so that they can be used interchangeably.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Create a lookup table mfc_table where mfc_table[word] contains the tag label most frequently assigned to that word</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="n">FakeState</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;FakeState&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MFCTagger</span><span class="p">:</span>
    <span class="c1"># NOTE: You should not need to modify this class or any of its methods</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="n">FakeState</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;&lt;MISSING&gt;&quot;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">MFCTagger</span><span class="o">.</span><span class="n">missing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">word</span><span class="p">:</span> <span class="n">FakeState</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        
    <span class="k">def</span> <span class="nf">viterbi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method simplifies predictions by matching the Pomegranate viterbi() interface&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;&lt;end&gt;&quot;</span><span class="p">]))</span>

<span class="n">mfc_table</span><span class="o">=</span><span class="p">{}</span>

<span class="c1">#use pair_counts to create dictionary with words as keys and (tags,frequence) as value</span>
<span class="n">word_counts</span> <span class="o">=</span> <span class="n">pair_counts</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>


<span class="c1">#get the tag with max value by using the max function with value as key</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">word_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">mfc_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>


<span class="n">mfc_model</span> <span class="o">=</span> <span class="n">MFCTagger</span><span class="p">(</span><span class="n">mfc_table</span><span class="p">)</span> <span class="c1"># Create a Most Frequent Class tagger instance</span>

<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mfc_table</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">vocab</span><span class="p">),</span> <span class="s2">&quot;&quot;</span>
<span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">vocab</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mfc_table</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="s2">&quot;&quot;</span>
<span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mfc_table</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">vocab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5521</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your MFC tagger has all the correct words!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your MFC tagger has all the correct words!</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Making-Predictions-with-a-Model">Making Predictions with a Model<a class="anchor-link" href="#Making-Predictions-with-a-Model"> </a></h3><p>The helper functions provided below interface with Pomegranate network models &amp; the mocked MFCTagger to take advantage of the <a href="http://pomegranate.readthedocs.io/en/latest/nan.html">missing value</a> functionality in Pomegranate through a simple sequence decoding function. Run these functions, then run the next cell to see some of the predictions made by the MFC tagger.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">replace_unknown</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a copy of the input sequence where each unknown word is replaced</span>
<span class="sd">    by the literal string value &#39;nan&#39;. Pomegranate will ignore these values</span>
<span class="sd">    during computation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">w</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">vocab</span> <span class="k">else</span> <span class="s1">&#39;nan&#39;</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">simplify_decoding</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;X should be a 1-D sequence of observations for the model to predict&quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">state_path</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">viterbi</span><span class="p">(</span><span class="n">replace_unknown</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># do not show the start/end state predictions</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example-Decoding-Sequences-with-MFC-Tagger">Example Decoding Sequences with MFC Tagger<a class="anchor-link" href="#Example-Decoding-Sequences-with-MFC-Tagger"> </a></h3>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">keys</span><span class="p">[:</span><span class="mi">3</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sentence Key: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Predicted labels:</span><span class="se">\n</span><span class="s2">-----------------&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">simplify_decoding</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sentences</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">words</span><span class="p">,</span> <span class="n">mfc_model</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Actual labels:</span><span class="se">\n</span><span class="s2">--------------&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sentences</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Sentence Key: b100-28144

Predicted labels:
-----------------
[&#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;.&#39;]

Actual labels:
--------------
(&#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;.&#39;)


Sentence Key: b100-23146

Predicted labels:
-----------------
[&#39;PRON&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;.&#39;]

Actual labels:
--------------
(&#39;PRON&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;.&#39;)


Sentence Key: b100-35462

Predicted labels:
-----------------
[&#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;&lt;MISSING&gt;&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADV&#39;, &#39;NOUN&#39;, &#39;.&#39;]

Actual labels:
--------------
(&#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;)


</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Evaluating-Model-Accuracy">Evaluating Model Accuracy<a class="anchor-link" href="#Evaluating-Model-Accuracy"> </a></h3><p>The function below will evaluate the accuracy of the MFC tagger on the collection of all sentences from a text corpus.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">accuracy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the prediction accuracy by using the model to decode each sequence</span>
<span class="sd">    in the input X and comparing the prediction with the true labels in Y.</span>
<span class="sd">    </span>
<span class="sd">    The X should be an array whose first dimension is the number of sentences to test,</span>
<span class="sd">    and each element of the array should be an iterable of the words in the sequence.</span>
<span class="sd">    The arrays X and Y should have the exact same shape.</span>
<span class="sd">    </span>
<span class="sd">    X = [(&quot;See&quot;, &quot;Spot&quot;, &quot;run&quot;), (&quot;Run&quot;, &quot;Spot&quot;, &quot;run&quot;, &quot;fast&quot;), ...]</span>
<span class="sd">    Y = [(), (), ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="n">total_predictions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">observations</span><span class="p">,</span> <span class="n">actual_tags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        
        <span class="c1"># The model.viterbi call in simplify_decoding will return None if the HMM</span>
        <span class="c1"># raises an error (for example, if a test sentence contains a word that</span>
        <span class="c1"># is out of vocabulary for the training set). Any exception counts the</span>
        <span class="c1"># full sentence as an error (which makes this a conservative estimate).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">most_likely_tags</span> <span class="o">=</span> <span class="n">simplify_decoding</span><span class="p">(</span><span class="n">observations</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
            <span class="n">correct</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">t</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">most_likely_tags</span><span class="p">,</span> <span class="n">actual_tags</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">total_predictions</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="n">total_predictions</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Evaluate-the-accuracy-of-the-MFC-tagger">Evaluate the accuracy of the MFC tagger<a class="anchor-link" href="#Evaluate-the-accuracy-of-the-MFC-tagger"> </a></h4><p>Run the next cell to evaluate the accuracy of the tagger on the training and test corpus.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">mfc_training_acc</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">mfc_model</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;training accuracy mfc_model: </span><span class="si">{:.2f}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">mfc_training_acc</span><span class="p">))</span>

<span class="n">mfc_testing_acc</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">mfc_model</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;testing accuracy mfc_model: </span><span class="si">{:.2f}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">mfc_testing_acc</span><span class="p">))</span>

<span class="k">assert</span> <span class="n">mfc_training_acc</span> <span class="o">&gt;=</span> <span class="mf">0.955</span><span class="p">,</span> <span class="s2">&quot;Uh oh. Your MFC accuracy on the training set doesn&#39;t look right.&quot;</span>
<span class="k">assert</span> <span class="n">mfc_testing_acc</span> <span class="o">&gt;=</span> <span class="mf">0.925</span><span class="p">,</span> <span class="s2">&quot;Uh oh. Your MFC accuracy on the testing set doesn&#39;t look right.&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your MFC tagger accuracy looks correct!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>training accuracy mfc_model: 95.72%
testing accuracy mfc_model: 93.01%
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your MFC tagger accuracy looks correct!</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Step-3:-Build-an-HMM-tagger">Step 3: Build an HMM tagger<a class="anchor-link" href="#Step-3:-Build-an-HMM-tagger"> </a></h2><hr />
<p>The HMM tagger has one hidden state for each possible tag, and parameterized by two distributions: the emission probabilties giving the conditional probability of observing a given <strong>word</strong> from each hidden state, and the transition probabilities giving the conditional probability of moving between <strong>tags</strong> during the sequence.</p>
<p>We will also estimate the starting probability distribution (the probability of each <strong>tag</strong> being the first tag in a sequence), and the terminal probability distribution (the probability of each <strong>tag</strong> being the last tag in a sequence).</p>
<p>The maximum likelihood estimate of these distributions can be calculated from the frequency counts as described in the following sections where you'll implement functions to count the frequencies, and finally build the model. The HMM model will make predictions according to the formula:</p>
<p>
$$t_i^n = \underset{t_i^n}{\mathrm{argmax}} \prod_{i=1}^n P(w_i|t_i) P(t_i|t_{i-1})$$
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="IMPLEMENTATION:-Unigram-Counts">IMPLEMENTATION: Unigram Counts<a class="anchor-link" href="#IMPLEMENTATION:-Unigram-Counts"> </a></h3><p>Complete the function below to estimate the co-occurrence frequency of each symbol over all of the input sequences. The unigram probabilities in our HMM model are estimated from the formula below, where N is the total number of samples in the input. (You only need to compute the counts for now.)</p>
<p>
$$P(tag_1) = \frac{C(tag_1)}{N}$$
</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">unigram_counts</span><span class="p">(</span><span class="n">sequences</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a dictionary keyed to each unique value in the input sequence list that</span>
<span class="sd">    counts the number of occurrences of the value in the sequences list. The sequences</span>
<span class="sd">    collection should be a 2-dimensional array.</span>
<span class="sd">    </span>
<span class="sd">    For example, if the tag NOUN appears 275558 times over all the input sequences,</span>
<span class="sd">    then you should return a dictionary such that your_unigram_counts[NOUN] == 275558.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">Counter</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">sequences</span><span class="p">))</span>

<span class="c1"># TODO: call unigram_counts with a list of tag sequences from the training set</span>
<span class="n">tag_unigrams</span> <span class="o">=</span> <span class="n">unigram_counts</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">tag_unigrams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">tagset</span><span class="p">,</span> \
       <span class="s2">&quot;Uh oh. It looks like your tag counts doesn&#39;t include all the tags!&quot;</span>
<span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">tag_unigrams</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_unigrams</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> \
       <span class="s2">&quot;Hmmm...&#39;X&#39; is expected to be the least common class&quot;</span>
<span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">tag_unigrams</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_unigrams</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;NOUN&#39;</span><span class="p">,</span> \
       <span class="s2">&quot;Hmmm...&#39;NOUN&#39; is expected to be the most common class&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your tag unigrams look good!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your tag unigrams look good!</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="IMPLEMENTATION:-Bigram-Counts">IMPLEMENTATION: Bigram Counts<a class="anchor-link" href="#IMPLEMENTATION:-Bigram-Counts"> </a></h3><p>Complete the function below to estimate the co-occurrence frequency of each pair of symbols in each of the input sequences. These counts are used in the HMM model to estimate the bigram probability of two tags from the frequency counts according to the formula: $$P(tag_2|tag_1) = \frac{C(tag_2|tag_1)}{C(tag_2)}$$</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">nltk</span>
<span class="k">def</span> <span class="nf">bigram_counts</span><span class="p">(</span><span class="n">sequences</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a dictionary keyed to each unique PAIR of values in the input sequences</span>
<span class="sd">    list that counts the number of occurrences of pair in the sequences list. The input</span>
<span class="sd">    should be a 2-dimensional array.</span>
<span class="sd">    </span>
<span class="sd">    For example, if the pair of tags (NOUN, VERB) appear 61582 times, then you should</span>
<span class="sd">    return a dictionary such that your_bigram_counts[(NOUN, VERB)] == 61582</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">bigrams</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">sequences</span><span class="p">)))</span>

        
<span class="c1"># TODO: call bigram_counts with a list of tag sequences from the training set</span>
<span class="n">tag_bigrams</span> <span class="o">=</span> <span class="n">bigram_counts</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag_bigrams</span><span class="p">)</span> <span class="o">==</span> <span class="mi">144</span><span class="p">,</span> \
       <span class="s2">&quot;Uh oh. There should be 144 pairs of bigrams (12 tags x 12 tags)&quot;</span>
<span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">tag_bigrams</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_bigrams</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;NUM&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;PRON&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)],</span> \
       <span class="s2">&quot;Hmmm...The least common bigram should be one of (&#39;X&#39;, &#39;NUM&#39;) or (&#39;PRON&#39;, &#39;X&#39;).&quot;</span>
<span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">tag_bigrams</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_bigrams</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="s1">&#39;DET&#39;</span><span class="p">,</span> <span class="s1">&#39;NOUN&#39;</span><span class="p">)],</span> \
       <span class="s2">&quot;Hmmm...(&#39;DET&#39;, &#39;NOUN&#39;) is expected to be the most common bigram.&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your tag bigrams look good!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your tag bigrams look good!</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="IMPLEMENTATION:-Sequence-Starting-Counts">IMPLEMENTATION: Sequence Starting Counts<a class="anchor-link" href="#IMPLEMENTATION:-Sequence-Starting-Counts"> </a></h3><p>Complete the code below to estimate the bigram probabilities of a sequence starting with each tag.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">starting_counts</span><span class="p">(</span><span class="n">sequences</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a dictionary keyed to each unique value in the input sequences list</span>
<span class="sd">    that counts the number of occurrences where that value is at the beginning of</span>
<span class="sd">    a sequence.</span>
<span class="sd">    </span>
<span class="sd">    For example, if 8093 sequences start with NOUN, then you should return a</span>
<span class="sd">    dictionary such that your_starting_counts[NOUN] == 8093</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#Count the frequence of tag if tag appears at first index to count the frequency</span>
    <span class="k">return</span> <span class="n">Counter</span><span class="p">([</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">])</span>

                
    

<span class="c1"># TODO: Calculate the count of each tag starting a sequence</span>
<span class="n">tag_starts</span> <span class="o">=</span> <span class="n">starting_counts</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag_starts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;Uh oh. There should be 12 tags in your dictionary.&quot;</span>
<span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">tag_starts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_starts</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s2">&quot;Hmmm...&#39;X&#39; is expected to be the least common starting bigram.&quot;</span>
<span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">tag_starts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_starts</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;DET&#39;</span><span class="p">,</span> <span class="s2">&quot;Hmmm...&#39;DET&#39; is expected to be the most common starting bigram.&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your starting tag counts look good!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your starting tag counts look good!</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="IMPLEMENTATION:-Sequence-Ending-Counts">IMPLEMENTATION: Sequence Ending Counts<a class="anchor-link" href="#IMPLEMENTATION:-Sequence-Ending-Counts"> </a></h3><p>Complete the function below to estimate the bigram probabilities of a sequence ending with each tag.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">ending_counts</span><span class="p">(</span><span class="n">sequences</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a dictionary keyed to each unique value in the input sequences list</span>
<span class="sd">    that counts the number of occurrences where that value is at the end of</span>
<span class="sd">    a sequence.</span>
<span class="sd">    </span>
<span class="sd">    For example, if 18 sequences end with DET, then you should return a</span>
<span class="sd">    dictionary such that your_starting_counts[DET] == 18</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Count the frequence of tag if tag appears at last index to count the frequency</span>
    <span class="k">return</span> <span class="n">Counter</span><span class="p">([</span><span class="n">tag</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">])</span>

<span class="c1"># TODO: Calculate the count of each tag ending a sequence</span>
<span class="n">tag_ends</span> <span class="o">=</span> <span class="n">ending_counts</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag_ends</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;Uh oh. There should be 12 tags in your dictionary.&quot;</span>
<span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">tag_ends</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_ends</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;CONJ&#39;</span><span class="p">],</span> <span class="s2">&quot;Hmmm...&#39;X&#39; or &#39;CONJ&#39; should be the least common ending bigram.&quot;</span>
<span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">tag_ends</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">tag_ends</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s2">&quot;Hmmm...&#39;.&#39; is expected to be the most common ending bigram.&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your ending tag counts look good!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your ending tag counts look good!</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="IMPLEMENTATION:-Basic-HMM-Tagger">IMPLEMENTATION: Basic HMM Tagger<a class="anchor-link" href="#IMPLEMENTATION:-Basic-HMM-Tagger"> </a></h3><p>Use the tag unigrams and bigrams calculated above to construct a hidden Markov tagger.</p>
<ul>
<li>Add one state per tag<ul>
<li>The emission distribution at each state should be estimated with the formula: $P(w|t) = \frac{C(t, w)}{C(t)}$</li>
</ul>
</li>
<li>Add an edge from the starting state <code>basic_model.start</code> to each tag<ul>
<li>The transition probability should be estimated with the formula: $P(t|start) = \frac{C(start, t)}{C(start)}$</li>
</ul>
</li>
<li>Add an edge from each tag to the end state <code>basic_model.end</code><ul>
<li>The transition probability should be estimated with the formula: $P(end|t) = \frac{C(t, end)}{C(t)}$</li>
</ul>
</li>
<li>Add an edge between <em>every</em> pair of tags<ul>
<li>The transition probability should be estimated with the formula: $P(t_2|t_1) = \frac{C(t_1, t_2)}{C(t_1)}$</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">basic_model</span> <span class="o">=</span> <span class="n">HiddenMarkovModel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;base-hmm-tagger&quot;</span><span class="p">)</span>

<span class="c1"># TODO: create states with emission probability distributions P(word | tag) and add to the model</span>
<span class="c1"># (Hint: you may need to loop &amp; create/add new states)</span>
<span class="n">states</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">tagset</span><span class="p">:</span>
    <span class="n">probability</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">counts</span> <span class="ow">in</span> <span class="n">emission_counts</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">probability</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">tag_unigrams</span> <span class="p">[</span><span class="n">tag</span><span class="p">]</span>
    <span class="n">emission_probability</span> <span class="o">=</span> <span class="n">DiscreteDistribution</span><span class="p">(</span><span class="n">probability</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">State</span><span class="p">(</span><span class="n">emission_probability</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">tag</span><span class="p">)</span>
    <span class="n">basic_model</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">states</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>

<span class="c1"># TODO: add edges between states for the observed transition frequencies P(tag_i | tag_i-1)</span>
<span class="c1"># (Hint: you may need to loop &amp; add transitions</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">tagset</span><span class="p">:</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
    <span class="n">basic_model</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">basic_model</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">tag_starts</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tag_starts</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">basic_model</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">basic_model</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">tag_ends</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tag_ends</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    
    
<span class="k">for</span> <span class="n">tag1</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">tagset</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">tag2</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">tagset</span><span class="p">:</span>
        <span class="n">basic_model</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">tag1</span><span class="p">],</span> <span class="n">states</span><span class="p">[</span><span class="n">tag2</span><span class="p">],</span> <span class="n">tag_bigrams</span><span class="p">[(</span><span class="n">tag1</span><span class="p">,</span><span class="n">tag2</span><span class="p">)]</span><span class="o">/</span><span class="n">tag_unigrams</span><span class="p">[</span><span class="n">tag1</span><span class="p">])</span>
        
<span class="c1"># finalize the model</span>
<span class="n">basic_model</span><span class="o">.</span><span class="n">bake</span><span class="p">()</span>

<span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">tag</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">basic_model</span><span class="o">.</span><span class="n">states</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">tagset</span><span class="p">),</span> \
       <span class="s2">&quot;Every state in your network should use the name of the associated tag, which must be one of the training set tags.&quot;</span>
<span class="k">assert</span> <span class="n">basic_model</span><span class="o">.</span><span class="n">edge_count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">168</span><span class="p">,</span> \
       <span class="p">(</span><span class="s2">&quot;Your network should have an edge from the start node to each state, one edge between every &quot;</span> <span class="o">+</span>
        <span class="s2">&quot;pair of tags (states), and an edge from each state to the end node.&quot;</span><span class="p">)</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your HMM network topology looks good!&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your HMM network topology looks good!</div>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">hmm_training_acc</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">training_set</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">basic_model</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;training accuracy basic hmm model: </span><span class="si">{:.2f}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">hmm_training_acc</span><span class="p">))</span>

<span class="n">hmm_testing_acc</span> <span class="o">=</span> <span class="n">accuracy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">basic_model</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;testing accuracy basic hmm model: </span><span class="si">{:.2f}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">hmm_testing_acc</span><span class="p">))</span>

<span class="k">assert</span> <span class="n">hmm_training_acc</span> <span class="o">&gt;</span> <span class="mf">0.97</span><span class="p">,</span> <span class="s2">&quot;Uh oh. Your HMM accuracy on the training set doesn&#39;t look right.&quot;</span>
<span class="k">assert</span> <span class="n">hmm_testing_acc</span> <span class="o">&gt;</span> <span class="mf">0.955</span><span class="p">,</span> <span class="s2">&quot;Uh oh. Your HMM accuracy on the testing set doesn&#39;t look right.&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;alert alert-block alert-success&quot;&gt;Your HMM tagger accuracy looks correct! Congratulations, you</span><span class="se">\&#39;</span><span class="s1">ve finished the project.&lt;/div&gt;&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>training accuracy basic hmm model: 97.53%
testing accuracy basic hmm model: 96.16%
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div class="alert alert-block alert-success">Your HMM tagger accuracy looks correct! Congratulations, you've finished the project.</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example-Decoding-Sequences-with-the-HMM-Tagger">Example Decoding Sequences with the HMM Tagger<a class="anchor-link" href="#Example-Decoding-Sequences-with-the-HMM-Tagger"> </a></h3>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">testing_set</span><span class="o">.</span><span class="n">keys</span><span class="p">[:</span><span class="mi">3</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sentence Key: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Predicted labels:</span><span class="se">\n</span><span class="s2">-----------------&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">simplify_decoding</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sentences</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">words</span><span class="p">,</span> <span class="n">basic_model</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Actual labels:</span><span class="se">\n</span><span class="s2">--------------&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sentences</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Sentence Key: b100-28144

Predicted labels:
-----------------
[&#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;.&#39;]

Actual labels:
--------------
(&#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;NOUN&#39;, &#39;NUM&#39;, &#39;.&#39;, &#39;.&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;.&#39;)


Sentence Key: b100-23146

Predicted labels:
-----------------
[&#39;PRON&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;.&#39;]

Actual labels:
--------------
(&#39;PRON&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;VERB&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;.&#39;)


Sentence Key: b100-35462

Predicted labels:
-----------------
[&#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;]

Actual labels:
--------------
(&#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;VERB&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADP&#39;, &#39;DET&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;ADJ&#39;, &#39;.&#39;, &#39;CONJ&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;ADP&#39;, &#39;ADJ&#39;, &#39;NOUN&#39;, &#39;.&#39;)


</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h6 id="NOTE:-This-project-is-part-of-NLP-Nano-degree-from-Udacity.">NOTE: This project is part of NLP Nano degree from Udacity.<a class="anchor-link" href="#NOTE:-This-project-is-part-of-NLP-Nano-degree-from-Udacity."> </a></h6>
</div>
</div>
</div>
</div>



  </div><a class="u-url" href="/DumbMachine/2020/06/02/Part-of-Speech-Tagging-with-Hidden-Markov-Models.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/DumbMachine/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/DumbMachine/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/DumbMachine/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>An introductory blog on approaching Machine Learning/Deep Learning Problems.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/ehtasham" title="ehtasham"><svg class="svg-icon grey"><use xlink:href="/DumbMachine/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/ehtashamawan" title="ehtashamawan"><svg class="svg-icon grey"><use xlink:href="/DumbMachine/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
